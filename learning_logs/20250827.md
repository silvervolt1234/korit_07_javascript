# JavaScript 학습 준비
1. vscode
2. Node.js
  - 서버 프로그램 개발을 자바스크립트로 가능하게 하는 자바스크립트 런타임 환경
  - 자바스크립트는 브라우저에서 동작하는 언어로 Java를 inteliJ에서 굴리는 것처럼 개발 환경을 구성하기 위한 것과 같음(유사 console.log)
  - 크롬에서 nodejs 검색
  - 설치 -> automatically install이 나오면 그것만 체크하고 나머지는 전부 default
  - 붉은 에러는 무시하고 enter 입력해서 최종 설치 후 vscode 재 실행
  - 터미널에서 node -v로 버전 확인

  - npm -v
  - 터미널이 powershell이면 보안이 걸리니 bash / cmd로 확인
## vscode extension 설치
1. JavaScript (ES6) code snippets
2. ESLint
  - ES + Lint로 EX ECMA Script, Lint는 소스 코드를 분석해 프로그램 오류, 버그, 스타일 오류, 의심스러운 구조체의 표시를 다는 것으로 JS 문법 오류 체크

# JavaScript 기본 문법

## 자바 스크립트 작성 위치
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JavaScript 코드의 작성 위치</title>
  <script>
    // 여기에 내용을 쓰고 주석처리를 하면
    //  1. 첫 번째 위치로 head 태그 내에 sccript 태그를 생성해 태그 안에 작성 사능
    document.write('자바스크립트 head 태그에 위치<br>');
  </script>
  <!-- <script src="01_js_location.js"></script> -->
</head>
<body>
  <!-- 여기에 내용을 작성하고 ctrl + / 를 하면 주석 처리 -->
   <script>
    // 2. 바디 태그내에 script 태그를 생성해 js 코드 작성
    document.write('자바스크립트 바디 태그에 위치<br>');
    // 3. 01_js_location.jss 생성
   </script>
   <script src="01_js_location.js"></script>
</body>
</html>
```
1. head 태그 내에 script 태그 생성 후 직접 js 코드 작성
2. body 태그 내에 script 태그 생성 후 직접 js 코드 작성
3. 별개의 js파일을 생성 후 head / body 태그에 script src 부분에 .js 파일 경로 삽입

- 참고 : 추가 확장 프로그램 Code Runner 설치
  -  설치시 js에서 실행하면 콘솔창에 코드 결과 출력
    -단 html과 연동이 아닌 js만 읽어서 임시방편이고 개발자 도구를 못 써서 console.log를 확인 못해 둘 다 사용하는 경우는 live server로 크롬 개발자 도구의 console과 문서화면 확인

console이라는 객체의 .log 메서드가 무슨 역할인지
document라는 객체의 .write가 무슨 역할인지

## 변수와 상수
1. 변수(variable) : 데이터를 담는 그릇. JS에서는 변수에 literal 뿐만 아니라 객체도 담을 수 있고 함수도 담을 수 있음
2. 상수(const) : 변화하지 않는 값을 가지고 있는 변수

### 변수 선언 형식
형식
선언자 변수명 = 데이터;
```js
var greeting = 'Hello, World!';
console.log(greeting)
```

- 변수 선언 규칙
1. 변수명은 문자(특수문자 제외), 숫자, _(언더스코어), $(달러 기호)를 포함하여 생성
2. 변수명은 숫자로 시작 불가능
3. JS 예약어는 사용 불가(document를 변수명으로 못함)
4. 대소문자 구분
5. 스크립트 표준인 ECMA Script에서는 변수명 / 함수명은 카멜 케이스를 사용하고 클래스명, 생성자 명에는 파스칼 케이스 사용 권장

### var 선언자
Js상에서는 데이터 타입(자료형)에 관계없이 변수를 저장할 때 var 선언자와 let 선언자를 사용 가능. 실무에서는 주로 let 사용

```js
var x = 5;
var y = 6;
var z = x + y;    // 11이 저장
```

여기까지는 int와 비슷하고 String 대신해서 자료형 없이 처음 쓸때마다 var 쓰는걸로 이해할 수 있지만

```js
var x = 5;
var y = 6;
var z = x + y;    // 11이 저장

var x = 7;
z = x + y;        // 13이 저장
```

그런데 x라는 변수에 다시 선언자를 쓰고 다시 한 번 선언된 변수가 z이기에 선언자를 사용하지 않았음에도 오류가 없음

이상의 경우 생기는 문제점은 동일한 변수명에 전혀 다른 기능을 넣었을 때
예를 들어 A가 var x 선언해서 어떤 값을 집어넣고 그걸로 기능을 실행하다가 협업하는 B 개발자가 var x를 재선언해서 다른 값을 집어넣고 새로 넣은 x 데이터 기준으로 기능 실행하면 오류 발생

테스트 중간에는 확인이 불가능. java처럼 컴파일링을 하는게 아니기에
```js
console.log(a);
var a = 10;
console.log(a);
```
이런 코드 라인도 오류 발생이 없다. 하지만 많은 웹사이트들이 var을 사용해 코드를 작성해 서비스하고 있기에 var을 막는건 무리가 있어 ES6부터는 let이라는 선언자를 추가로 만들어 이를 사용하는 쪽을 권장

### let 선언자
ES6 이후 추가된 선언자로 사실상 전부 동일. var의 문제점을 해결하기 위해 등장했기 때문에 int/String/double 등등을 대신해 let을 사용

1. 재대입을 할 때 let을 또 쓰면 오류 발생
2. 순서대로 실행되서
```js
console.log(a);
var a = 20;
console.log(a);
```
같은 방식으로 작성하면 오류 140번 라인에서 발생

### const 선언자(상수)
마찬가지로 ES6에 추가된 선언자로 상수(constant)는 변화하지 않는 변수를 의미
Java를 쓸 때는 웬만하면 final을 쓰지 않은것에 비해 JS는 웬만하면 const 권장. 그러면 값이 안 바뀌기에 웹 서비스상에서의 유연성이 없는거로 느껴질 수 있음

```js
const x = 3;
const y = 4;
const z = x + 7;

x = 5; // 오류 발생
```

그러면 const를 사용할 때는 어플에서 날짜를 보여주는 화면이 있다고 가정했을 때
1. 20250827
2. 2025-08-27
3. 2025/08/27
4. 2025.08.27
등을 예시로 둘 수 있는데 특정페이지는 1번, 다른 페이지는 3번을 사용하지 않을거고 동일한 웹 서비스라면 하나의 양식으로 날짜를 출력한다. 이런 경우 날짜 포맷 자체를 const로 선언
```js
const DATE_FORMAT = 'yyyy-mm-dd'  // 같은 방식
```
그러면 DATE_FORMAT이 고정되어 2025 08 27을 대입 불가능할거 같은데

## 데이터 타입
### 기본 자료형
1. string
2. number(숫자 전체로 정수 실수를 가리지 않는다)
3. boolean
4. undefined
5. null
6. symbol
#### string -> 패스
```js
console.log("제 이름은 '서문성'입니다.");
consoel.log('오늘 점심 뭐 먹지 "햄부기"');

let name1 = "John Doe";
let name2 = 'John Doe'; // 어느 쪽이든 무관
```
#### number -> int /short / long / double / float 퉁쳐서 number
#### boolean -> 패싱
#### underfined
  - 자료형이며 동시에 데이터값에 해당. 정의되지 않음을 의미하고 변수를 선언하고 아무 값을 할당하지 않으면 undefined가 자동 할당

#### null
  - null도 undefined처럼 자료형이면서 데이터 값에 해당하는데 둘 다 변수에 값이 없는 상태
  - undefined는 웹 브라우저 상에서 JS를 실행할 때 값이 할당되지 않은 변수에 대해서 자동으로 undefined를 할당. 개발자가 아닌 브라우저 엔진이 할당하고 리턴
  - null의 경우는 개발자가 평가해서 사용하는데 선언된 변수에 대해 어떤 값을 할당할지 모르면 개발자가 명시적으로 null을 대입한 것
  - 변수에 null을 할당하면 변수가 이전에 참조하던 값을 더 이상 참조하지 않기에 메모리 효율성 향상. Java의 경우 garbage collector가 있기에 오랬동안 변수 참조를 안하면 알아서 제거되는것 처럼 JS도 일정 주기를 기준으로 메모리 공간을 확보하는데 이때 null을 확힌하면 더 이상 해당 변수 참조를 안 함

#### symbol
  - ES6에 추가된 새로운 자료형

### 객체(Object)
- 자료형 개념으로서의 Object
js의 모든 것은 객체로 이루어져있으나 데이터 관점에서 사용하는건 Object와 Array

#### Object
object는 키(key)-값(value) 쌍으로 데이터를 저장
```js
const person = {
  firstName: 'Jone',
  lastName: 'Doe',
  age: 20,
  eyeColer: 'blue'
};
```
앞 부분이 key고 뒷부분이 value. 그리고 JS상에서의 키-값 쌍을 property

```js
// 객체의 property 수정 방법 # 1
person.firstName('일');     // access modifeir 전에 Java에서의 field 수정법
person.lastName('김');
console.log(person);

// 객체의 property 수정 방법 # 2
person['eyeColer'] = '검은색';  // Java에서의 Map 수정법
console.log(person);
```

#### Array(배열)

하나 이상의 데이터를 하나의 변수명에 관리하기 위한 방법으로 학술적으로 풀어 쓰면 하나의 단일 참조(single refernce)를 통해 다수 값을 확인 가능한 구조. 배열에 저장된 데이터의 특징은 순서를 가진다는 것

```js
const cars = ['Hyundai', 'Kia', 'Ford', 'Nissan'];
```
Java와의 차이점은 {}이냐 []로 들 수 있고 나머지는 거의 동일한데

```js
console.log(cars[0]);
```
으로 출력 가능
- element 값 바꾸는 법

```js
cars[1] = 'Honda';
console.log(cars[1]); // Kia 아니고 Honda 출력
```

### typeof 연산자
Java는 처음 변수 선언할 때 자료형을 명시하기에 필요없는 개념에 가깝지만 JS는 현재 변수에 어느 자료형이 들어가 있는지 확인할 필요 존재. 이상의 경우 사용하는 연산자

```js
let x = '안녕'
let y = 30;

// typeof 사용법
console.log(typeof x);  // string
console.log(typeof y);  // number

console.log(typeof {x:1, y:2});   // object
console.log(typeof [1,2,3]);   // object
console.log(typeof null);   // object
```
JS에서는 배열도 object에 해당

## 연산자(Operator)

### 할당 연산자
  - 연산 결과를 = 왼쪽에 있는 변수에 대입할 때 사용하는 연산자들로,
    +, -, *, /, % 까지는 Java와 동일
    하지만 **가 있는데
  - ** 지수할당 연산자

```js
let x = 2;
let y = 3;
z = x ** y;   // 2의 3제곱
console.log(z);   // 8
```

#### 복합 연산자
+=, -=, *=, /=, %=, **=

```js
let x = 3;
let y = 2;
console.log(x%=y); // x = x % y; -> 3 % 2

let a = 5;
let b = 2;
console.log(a**b);   // a = a ** b -> a = 5 ** 2 = 5 ^ 2 = 25
```
#### 비교 연산자
```js
let a = 3;
let b = '3';

console.log(a == b);  // true
console.log(a === b);  // false
```
js에서는 서로 다른 자료형일때도 비교가 가능한데 만약 string과 number를 비교해도 자료형 제외하고 내부 데이터 값만 비교해서 true 도출하는 결론 존재

- == : a와 b의 값이 같은지를 비교. 정확히는 string인 b를 number로 바꿔서 비교해 true return
- === : a와 b의 값 뿐만 아니라 자료형까지 비교
- != : 서로 다른지 비교
- !== : 자료형까지 확인해 다른지 비교
- `>` `<` `>=` `<=`

#### 산술연산자
++
--
#### 논리연산자
and &&
or ||
!: 변수 앞에 ! 써서 true `<->` false로 서로 반전
#### 문자열 연산자 
+만 적용
#### 삼항 연산자
형식
```js
// 조건 ? 값1 : 값2;
let age = 18;
let isAdult = (age >= 20) ? true : false; // 조건이 true면 true return, 아니면 false return
                                          // is로 시작하면 보통 boolean 자료형

// 심화
// 조건1 ? 값1 : 조건2 ? 값2 : 값3;
let point = 92;
let graed = (point >= 90) ? 'A' : (point >= 80) ? 'B' : 'C';
console.log(grade);
```

## 조건문
1. if문(if/ else if /  else 포함해서 한번에)

2. switch문

작성 방식은 java와 동일

## 반복문
반복문은 조건을 만족하는 동안 코드 블록을 반복적으로 수행. JS에서는 for / for-in / for-of / while 과 같은 반복문 지원

여기서 주목할 부분은

첫번째, 마지막 index에 해당하는 element 다음에 ',' 가 찍혀도 오류가 발생하지 않는다는 점

두번쨰, Array의 element인 object는 마지막 property의 value 값 다음에도 ','가 있지만 오류가 발생하지 않는다는 점

추후 property를 추가하거나 element를 추가할 때 쉼표 치고 엔터치고 다시 {} 혹은 property 추가하기 힘들기에 마지막 element/property 여부와 무관하게 쉼표를 찍어주는게 관행처럼 굳어져 오류처리 아님

1. for-loop문
  - java와 동일
  - 배열 내부의 객체가 element라면 배열 자체를 console.log(배열명);으로 출렬했을 때 결과값이 [object Object],[object Object],[object Object] 형식으로만 나오기에 각 객체의 명확한 상태를 알기 위해서는 배열의 element를 추출하는 반복문이 필요

2. for-in문
  - for-in문은 데이터 타입 중 배열뿐만 아니라 객체에도 사용 가능한 반복문으로 index 넘버를 사용하지 않고 key를 통해서 읽는 방식
  형식 :
  `for (const key in object명) {실행문};`

3. for-of 문
  - for-in문의 경우 객체 한정으로 생각. 일반적인 Java에서 enhanced for문에 해당하는 것을 for-of문이라 생각

4. while문
  - 일반 while문
    - Java와 동일
  - do while문
```js
let j = 1;
do {
  console.log(j);
  j++;
} while(j <= 10);
```

자주 쓰이는건 아니지만 일반 while문의 경우 true인지 false인지 조건식을 확인하고 true일 때만 코드블럭을 실행하는 반면 do-while문은 우선 코드불럭을 실행하고 조건식을 확인하는데 무조건 한번 실행을 담보하기 위함

  형식 
  ```js
  do {
    실행문;
  } while(조건식);
  ```

for - 반복 횟수가 명확할 때
while - 몇 번 반복할지 모를때

## 함수(function)
### 정의
일반적으로 프로그래밍 언어에서 특정 작업을 반복해야 하는 경우 해당 작업을 재사용 가능한 구조로 만드는데 이 때 사용되는 개념. 함수로 구현한 코드는 그 함수를 호출해 반복된 기능을 쉽게 처리
Js는 특별한 경우를 제외하고는 기능에 따라 함수를 작성하며 함수 안에 Js 프로그램 코드를 구현

- 즉 특정한 기능을 수행하기 위한 일련의 코드 블록을 하나의 실행 단위로 생성한 것

### 함수 선언(정의) 및 사용

형식
```js
function 함수명(매개변수1, 매개변수2) {
  let 지역변수 = 데이터;
  return 결과값;
}
```
- 함수 선언 키워드 function
- 함수명
- 매개변수(optional)
- 실행문에 해당하는 코드 블럭(함수 내에서 다른 함수를 호출 가능)
- 결과값(optional)

예시
```js
function sum(x, y) {
  let sum = x + y;
  return sum;
}

sum(10,20);   // 결과값 30이지만 console 출력 불가
console.log(sum(10,20));
```

### 함수 표현식
- 변수에 함수를 할당해서 사용하는 방식

형식
```js
let sum = funtction(매개변수1, 매개변수2) {
  let 지역변수 = 매개변수1, 매개변수2가 가지고.... 연산 실행문;
  return 결과값;
}

// 함수 표현식 예시
let sum = function(x, y) {
  let result = x + y;
  return result;
}

// 원래 함수 선언 방식
function sum(x, y) {
  let sum = x + y;
  return sum;
}

// 함수 호출 방식 
sum(10,20);
```

함수 표현식이란 개념이 나오느 이유 역시 var이 일으키는 문제와 유사
기존 함수 선언방식과 선언자 var의 경우 Js가 코드를 읽어들일 때 일단 var / function으로 되 있는 것들을 미리 메모리에 올려두는데 

그 의미는 먼저 변수/함수를 사용(호출)하고 나중에 선언/정의를 해도 무리가 없다는것

그래서 var 선언자 및 function 키워드는 Hosting이라는 특징으로 설명

하지만 var은 변수를 처음 선언할때만 사용하는지라 나중에 사용 가능하면 문제가 생길 수 있는데 var의 문제처럼 function명 역시 동일하면 더 밑의 지정된 것으로 덮어쓰기가 가능해 함수명이 겹치면 원하는 결과값이 나오지 않는다

이상을 이유로 function을 let에 등록하면 코드가 순서대로 동작된다는 점에 착안해 함수 표현식 개념이 등장

hosting 때문에 함수 표현식이 등장했고 이를 통해 담보가능한건 코드가 순서대로 실행된다는 점. 함수를 담고 있는 변수에 대한 코드 구문이 함수를 호출하는 코드 구문보다 뒤에 있으면 오류 발생

```js
let sum1 = sum(21, 22);   // 오류 발생
let sum2 = sum(34, 15);   // 오류 발생

let sum = function(x, y) {    // 함수 표현식이기에
  return x + y ;
}
```

### Function 생성자 함수
- JS 내장 함수인 Function 함수에 매개변수와 코드 블럭을 문자열로 순서대로 전달하여 생성

예시
```js
let sum = new Function('x', 'y', 'return x + y;')
let sum1 = sum(21, 22);
let sum2 = sum(22, 33);
```