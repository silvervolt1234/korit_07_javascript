# JavaScript 내장 객체
## Object 객체
내장 객체(Built-in Object)는 브라우저의 JS엔진에 내장된 객체를 의미. 모든 Object 객체는 모든 JS의 루트 객체

String, Number, Date, Array, Math, etc....

## String 객체
문자열을 다루는 property / 함수를 제공

1. length
```js
let txt = "abcd";
let txtLength = txt.length;
console.log('문자열의 길이는 ' + txtLength + '입니다.')
```

2. indexOf()
문자열 안에 특정 문자열이 존재하는지 찾고 문자열이 시작되는 index를 반환하는 method.
- 문자열을 찾지 못하면 -1을 retrun

3. lastIndexOf()
다 비슷하지만 찾고자 하는 문자열이 둘 이상 반복되면 제일 마지막에 발견된 문자열의 index를 return
- 문자열을 찾지 못하면 -1을 return

4. slice()
매개변수로 시작 위치 / 종료 위치를 줬을 때 문자열의 해당 부분을 잘라 return하는 method

5. substring()
- slice()와 똑같지만 마이너스 인덱스 없음

6. substr()
- slice()랑 비슷하지만 두 번째 한계갑 미만을 지시하는게 아닌 첫 번째 매개변수로부터의 문자 개수를 의미

7. replace()
- 문자열 내의 특정 문자열을 지정한 문자열로 바뀌는 함수
- vscode 상에서 ctrl + r을 눌러 문자열을 검색해 바꾸는 기능과 동일
- 정규식과 조합으로 다양한 replace() 적용 가능
  - `/i` : insensitive - 대소문자 구분 없음
  - `/g` : global : 일치하는 문자열 전체 replace() 적용

8. toUpperCase(), toLowerCase()

9. concat()
- 두 개 이상의 문자열을 하나의 문자열로 합치는 method

10. trim()
- 문자열 앞/뒤 공백을 모두 제거하는 함수
- DB에 공백이 있으면 조회할 때 실패하는 경우가 있어 공백을 제거하고 주로 조회

11. charAt()
- 문자열에서 특정 인덱스에 해당하는 문자 하나를 반환하는 method

12. charCodeAt()
- 문자열에서 특정 인덱스에 해당하는 문자의 유니코드 값 반환

13. split()
- 문자열 내의 특정 기준을 가지고 문자열을 분리해 배열로 반환하는 method

14. startsWith(), endsWith()
- 문자열의 시작 혹은 끝이 매개변수로 전달된 값으로 이루어져있는지 확인하는 method
- return type = boolean

  - 실무 사례
    startsWith('https')를 해서 보안이 뛰어난 https로 접속했는지 확인. 이 경우 false가 나오면 http로 접속했다는 뜻
    endsWith()는 특정 파일 확장자 여부를 판단하는 용도
    endswith('.pdf')와 같은 방식

## Number 객체

1. toString()

2. toFixed()
- 소수저 몇 번째 자리까지 보여줄지 결정하는 method
- 매개변수로 소수점 자리수 사용
- 반올림 적용

3. toPrecision()
- toFixed()와 다르게 정수와 소수를 포함해 몇 번째 자리까지 보여줄지 결정하는 method

4. parseInt()
- 전역 함수로 정수로 반환. 문자역의 시작이 number면 number로 반환

5. parseFloat()
- 전역 함수로 부동소수점으로 반환

## Array 객체

1. toString()
- 배열 내의 element들을 ',' 기준으로 모두 결합해 하나의 문자열로 return

2. join()
- 배열 내의 모든 문자를 매개변수로 지정한 문자를 이용해 element 구분. `배열명.join('/)` 라고 가정하면 결과값은
요소1 / 요소2 / 요소3 ... 으로 / 기준 결합

3. pop()
- 배열에서 마지막 데이터를 제거하고 마지막 데이터를 return

4. push()
- Java Collection에서 list /set에서 .add()와 동일

5. shift()
- pop()과 달리 첫 element를 제거하고 그 element를 return

6. unshift()
- 배열 맨 앞에 element를 추가하고 배열의 index를 return
- 맨 앞에 추가하는 method가 따로 있는 실무 사례
  - HTML 문서 작성시에 `<select>` 태그 구현할때, DB에서 지역목록을 가져오고 가져온 지역 목록을 `<select>` 태그의 `<option>` 태그로 추가하려고 할 때 `<select>` 태그에서 사용자에게 제일 먼저 보이는 옵션이 '선택하세요'와 같은 정보성 글
  이런 상황에서 DB에 '선택하세요'가 있지 않을것이니 unshift('지역을 선택하세요); 로 배열에 추가하는 방식 존재
  - html_css의 `<select>` 참고

7. 배열 element 변경
```js
let subs =['국어', '수학', '영어', '자바', '자바스크립트'];
sub[0] = '파이썬'
```

8. splice()
- 새로운 element를 특정 위치에 추가하는데 기본 element를 삭제 가능

```js
let fruits2 = ['Banana', 'Orange', 'Apple', 'Mango'];
fruits2.splice(2, 0, 'Lemon', 'Kiwi');
console.log(fruits2);
// 결과값 : (6) ['Banana', 'Orange', 'Lemon', 'Kiwi', 'Apple', 'Mango']
```

splice(2, 0, 'Lemon', 'Kiwi')의 매개변수 목록

  1. 2 : 새로운 element를 추가할 인덱스 넘버
  2. 0 : 첫 번째 매개변수에 해당하는 인덱스에서 element를 추가하기 전에 삭제할 element 수 -> 0으로 지정해서 아무것도 삭제 안됨
  3. 'Lemon', 'Kiwi' ... etc : 나머지 매개변수는 추가할 element에 해당

9. concat()
- 2개 이상의 배열을 하나의 배열로 결합

10. slice()
- String에서와 동일
- 단 배열 형태로 return

11. sort() -> 오름차순 정렬

12. reverse() -> 내림차순 정렬

13. filter()
- 배열에서 특정 조건을 만족하는 배열의 element만을 찾아서 새로운 배열로 return
- 배열을 다룰 때 가장 많이 쓰고 프론트엔드에서도 자주 사용하는 method
- 특정 조건만을 만족하는 데이터만 추출하는 프로그램을 작성하는 경우가 빈번한데 이때 filter()를 써서 필수적

형식:

`배열명.filter(콜백함수([, index[, 배열]])[, thisArg])`

filter() method는 특정 조건을 체크하는 callback 함수를 매개변수로 전달

여기서의 callback 함수는 배열의 각 element를 시험할 함수에 해당해 시험을 통과(true)하게되면 element를 그래도 유지하고 false면 버리게 되서 true인 element들만 모아 새로운 배열을 생성

이상에서 주의할 점은 persons를 가지고 새로운 배열을 만들었는데 persons의 element의 자료형은 object이므로 새로운 배열인 pass의 element도 여전히 object
  score를 가지고 비교했다고 해서 점수들을 element로 삼는게 아님

callback 함수의 매개변수는
  - element : 처리할 현재 element(기존 배열의 element를 의미)
  - index(optional) : 처리할 현재 element의 인덱스
  - array(optional) : 배열 전체

```js
let words = ['부산광역시', '부산시', '서울특별시', '서울', '경상남도 남해시', '남해시', '광주광역시', '경기도 광주시', '오사카부 오사카시', '오사카'];

let result = words.filter(function(words) {
return words.length > 4;
});
console.log(result);
// 결과값 : (6) ['부산광역시', '서울특별시', '경상남도 남해시', '광주광역시', '경기도 광주시', '오사카부 오사카시']
```

14. map()
- 배열 내에서 element가 object일 때 배열에 담긴 object를 새로운 형태의 object로 변환해 배열로 return

15. reduce()
- 배열에 담긴 element를 하나씩 순회하며 callback 함수의 실행값을 누적하여 return하는 method. 누적 결과 값은 숫자, 문자, 객체 모두 가능

- 주로 배열 내의 element 데이터의 합계를 구할때 사용

- 배열 내의 element가 객체인 경우 누적 값을 구하고자 하는 object의 property를 참조해서 사용(persons면 persons[0].score)

```js
// reduce
let scores = [40, 100, 1, 5, 25, 10];
let sum = scores.reduce(
  function(total, currentValue) {
      return total + currentValue;
  }
);  // 결과값: 181

console.log(sum);
```
reduce() method 내부의 callback 함수는 4개의 매개변수를 가질 수 있다(주로 2개만 쓰고 나머지는 optional)

- 1번 매개변수 : accumulator(누적값 = total)
- 2번 매개변수 : currentValue(배열의 현재 element)
- 3번 매개변수 : currentIndex(현재 index 번호)
- 4번 매개변수 : arr(배열)

## Set 객체

1. Set 생성자
```js
let mySet = new Set();
```
2. add() - java와 동일
3. has() - 특정 데이터기 있는지 확인. return boolean
4. delete() - 특정 데이터를 삭제
5. clear() - 저장된 모든 데이터를 삭제
6. forEach() - set에 저장된 모든 데이터 읽기
```js
mySet.forEach(function(item){
  console.log(item);
})
```

## Map 객체
1. Map 생성자
```js
let userMap = newMap();
```
2. set() - Map 객체에 데이터 저장할 때 사용.        
  Java에서의 맵 이름.put("키", "값");과 동일
3. get() - Java에서의 맵이름.get("키");와 동일
4. has() - 특정 키의 값이 저장되있는지 확인(return boolean)
5. delete() - 특정 데이터를 삭제
  userMap.delete('name');
6. clear() - 저장되있는 모든 데이터 삭제
7. forEach() - 저장된 모든 데이터 읽기
```js
userMap.forEach(function(item) {
  console.log(item);
});
```

### JavaScript Object vs JavaScript Map

1. Object는 key를 string으로만 지정해야 Map은 다른 타입도 가능
2. Object는 몇 개의 데이터가 담겼는지 수동 계산해야하지만 Map은 맵이름.size로 크기 측정 가능
3. Object는 저장된 데이터를 for-in으로 읽었을때 순서를 보장하지 않지만 Map은 순서대로 읽어옴(Java Map은 아님)

## JSON 객체
- 데이터를 저장하거나 전송할 때 많이 사용되는 경량의 데이터 교환 형식
- 다수의 플랫폼에 사용

1. 서버와 클라이언트간의 데이터 전송 시 많이 사용
2. JavaScript의 Object 객체 표시범과 매우 유사
3. JSON 데이터는 JavaScript JSON 객체의 parse() method를 이용하면 JavaScript Object 객체로 변환하며 사용 가능
4. 프로그램이 언어와 상관없이 사용할 수 있는 데이터 교환 방식
5. 대부븐의 언어에서 JSON 데이터를 처리할 수 있는 라이브러리 제공(JAVA는 GSON)

### 중요한 내장 함수 목록
1. JSON,stringify(Object명) - 데이터를 서버로 전송하기 이해 데이터 형태를 문자열로 변환(이유: 가벼움)

2. Json.parse(JSON명) - 서버로부터 응답받은 JSON데이터를 JavaScript Object의 객체로 변환

## Window 객체
window 객체는 전역(global) 객체. 현재는 브라우저라고 생각해도 무방

1. alert() - 윈도우 화면에 경고 메세지를 출력
2. confirm() - return type boolean

```js
if(confirm('정말 삭제하시겠습니까?')) {
  // 삭제 로직
  console.log('삭제');
}
```

3. prompt() -  문자열을 입력받을 수 있는 험수
```js
let txt = prompt('비밀번호를 입력하세요');

if(txt === null) {
  // 취소 버튼을 눌렀을 때 로직
} else if(txt === '') {
  // 아무 값도 입력하지 않고 확인 버튼 눌렀을 때의 로직
} else if(txt !== '') {
  // 어떤 값을 입력하고 확인 버튼을 누르면
  // 비밀번호 일치와 아닐때의 조건문 삽입
}
```

4. open() - 윈도우 새 창 / 새 탭으로 지정한 url을 오픈하는 함수

5. setTimeout() / clearTimeout()
  - setTimeout() 함수는 두 번째 매개변수로 지정한 시간 간격 이후에 첫 번째 매개변수에 정의한 함수를 실행. callback 개념 인지 필요

  - clearTimeout() - setTimeout() 함수에서 정의한 함수가 실행되지 않았으면 setTimeout()의 콜백 함수를 실행시키는걸 중지할 때 사용

  - 밀리초 사용

# JavaScript 고급 문법

## Default Function Parameter
- 함수를 호출할 때 `function(message) {return blabla};` message가 비어있는 상태라면 호출 단계에 argument가 없어서 오류 발생. 만약 매개변수가 함수 내에서 특정 기능 구현을 위해 반드시 요구되면, 아무런 값이 없을 경우 함수를 호출 할 때마다 체크를 해야 함

```js
funcation say(message) {
  if(message !== undifined) {
    console.log(message);
  } else {
    console.log('매개변수가 입력되지 않았습니다.');
  }
}

say();  // argument 없이 함수 호출 했다면
// 결과값 : 매개변수가 입력되지 않는다.
```

Default function parameter를 지정하면 argument없이 함수를 호출했을 때 미리 설정한 기본값으로 함수를 호출해 오류가 발생하지 않게 하는 사전 작업

```js
function say(message='매개변수가 입력되지 않았습니다.') {
  console.log(message);
}

say();
```

## Rest Parameter
일반적인 함수 선언식으로 함수에 따라 몇 개의 argument가 요구되는지 미리 선언. 매개변수 2개로 정의하면 함수 호출시에 2개의 argument를 요구하고 4개를 정의하면 4개를 요구. 그런데 3개를 쓰기 위해선 방법이 다름

문제 사례
```js
function sum(x1, x2) {
  return x1 + x2;
}

sum(5, 7);

function sum(x1, x2, x3, x4) {
  return x1 + x2 + x3 + x4;
}

sum(5, 7, 8, 10);
```
이런식이나 3개짜리 연산은 불가능해서 sum(1, 2, 3, 0) 같은 방식으로 우회해야함. Rest Parameter의 개념은 몇 개의 매개변수가 요구될 지 모르는 상황에서 유용함

Rest Parameter 적용 예시
```js
function sum(...args) { // 이렇게 매개변수를 선언하면 함수 호출 시에
                        // 매개변수 개수에 상관없이 할당이 가능하고 
                        // 그 값은 배열로 저장
  let total = 0;
  // 배열로 저장되기에 element를 추출해 합 연산
  for (let x of args) {
    total += x;
  }
  return total;
}

sum(1,2,3);
sum(2,4,56,8,8,123493834278);
```

## Arrow Function(Lambda Expression의 JS ver.)
기존 함수 표현 방식들
1. 함수 선언식
```js
function hello(name) {
  return 'hello' + name;
}
```
2. 함수 표현식
```js
const hello2 = function(name) {
  return 'hello ' + name;
}
```
hosting 여부로 인해 2가지 방법

화살표 함수는 함수를 정의하는 비교적 최근 방안. 화살표 함수로 함수를 정의하면 구문이 짧아지지만 너무 복잡한 로직을 구현하기는 힘듬

3. 화살표 함수
```js
// full form
const hello3 = (name) => {return 'Hello' + name};

// 매개변수가 하나라면 소괄호()를 생략 가능
const hell04 = name => {return 'Hello' + name};

// 실행문이 한 줄이면 return / 중괄호({})를 생략 가능
const hello5 = name => 'Hello' + name;

// 매개변수가 없다면 빈 소괄호 사용
const hello6 = () => 'Hello, there';
```

## Template Literals
```js
// 1. 기존 작성 방식
function hello(name) {
  console.log('Hello ' + name + '. 환영합니다!');
}

// 2. 템플릿 리터럴 적용 방식
function hello2(name) {
  console.log(`Hello ${name}. 환영합니다!`);
}
```
2의 장점은 중간에 연산자가 들어가도 오류 발생할 확륙이 적음. 하지만 '' / `` 를 구분하기 힘들어 ${}를 이용해 구분

## Object Literal Syntax Extension
```js
// 1. 기존 방식
let fName = 'Josh';
let lName = 'Smith';

let person = {
  fName: fName,   // 앞은 person의 property
  lName: lName,
}

// 2. Objectd Literal
let type = 'studernt';
let score = {
  [type]: 'Josh',
  score: 92,
}
```
Objectd Literal에서 key에 []가 있다는 점을 확인 할 수 있다. Js 객체의 key를 []로 감싸면 할당된 변수 값을 의미하게 되어 Js 객체의 key를 동적으로 생성 가능

## Spread Operator(JS에서 처음 학습)
- 배열, 문자열 등 반복가능객체 형태의 데이터를 element 하나하 분해해서 사용할 수 있게

## Object Destructing(객체 구조분해)
## Array Destructing(배열 구조분해)

# JS HTML DOM
- DOM(Document Object Model)
- JS는 HTML 문서의 모든 요소에 접근하여 변경 가능. 간단하게는 `<table>`태의 내의 `<td>`를 추가 가능

1. 모든 HTML element
2. HTML 태그의 속성(특성)
3. CSS 스타일
4. HTML element 및 속성을 제거
5. 새로운 HTML element 및 속성을 추가
6. 페이지 내에 존재하는 모든 HTML 이벤트에 대한 반응
7. 새로운 HTML 이벤트 추가

## DOM Element
Js에서 HTML element에 대한 다양한 제어를 위해 가장 먼저 할 일은 HTML element에 대한 접근. JS상에서 HTML 요소를 찾는 방법은

1. id를 통해
2. 태그명을 통해
3. class 명을 통해
4. CSS의 선택자 개념을 통해

- HTML element의 id로 찾기
  - HTML 태그의 id 속성은 고유값이기에 단일 결과
  - id가 정확하면 JS 객체의 형태로 HTML element가 return
  - 일치하는 id가 없으면 null return
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM element</title>
</head>
<body>
  <input id="userid" type="text">
  <p>태그명을 사용해서 HTML 요소를 찾습니다.  document.getElementById</p>
  <script>
    let element = document.getElementById('userid');

    console.log(element);
    console.log(typeof element);
    // 결과값 : object
  </script>
</body>
</html>
```

- 태그 명을 통한 HTML element 추출
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>태그명을 통한 HTML element</title>
</head>
<body>
  <p>HTML 요소에 대한 접근</p>
  <p>
    태그명을 사용하여 HTML element를 추출합니다. <br>
    document.getElementsByTagName('p');
  </p>
  <p class="para">
    여기는 클래스명을 통한 HTML 요소를 찾겠습니다. <br>
    document.getElementsByClassName('para');
  </p>
  <p class="para">
    하나 더 넣겠습니다.
  </p>
  <b class="para">이건 다른 태그의 동일한 클래스명입니다.</b>
  <p class="para">
    CSS 선택자를 이용하여 HTML element를 추출합니다. <br>
    document.querySelectorAll('p.para');
  </p>
  <script>
    let elements = document.getElementsByTagName('p');

    console.log(elements);

    let classElems = document.getElementsByClassName('para');

    console.log(classElems);

    let selectorResult = document.querySelectorAll('p.para');

    console.log(selectorResult);
    // 최근에는 querySelector로 HTML element 추출을 좀 더 많이하는 것 같습니다.
  </script>
</body>
</html>
```
- id값을 통한 추출과 태그명을 통한 추출에서의 차이점은 id는 고유값인데 태그는 한 HTML문서 내에서 복수로 있을 수 있어 return 타입이 JS 객체 하나짜리가 아닌 JS 객체를 element로 하는 배열이 return

- 이를 명확히 하기 위해서 method 명을 보면 
- getElement's'ByTagName이라고 명시됨

- 클래스 명을 통한 HTML 요소 찾기
- CSS 선택자를 이용한 HTML 요소 찾기

## HTML 내용 변경
1. inerHTML
  - HTML의 특정 위치에 새로운 HTML을 삽입할 때 사용

2. innerText
  - 1과 비슷하지만 텍스트 내용만 삽입 가능
## DOM event(클릭 이벤트 등)
웹 페이지를 이용하면 웹 화면과 사용자 사이 상호작용 발생. 예을 들어
1. 버튼 틀릭
2. 마우스 스크롤
3. 검색 키워드를 input창에 입력
등 모든 상호작용이 event

### click 이벤트(onclick) - react에서는 onClick
마우스 좌클릭시 발생하는 이벤트. 검색 / 저장과 같은 버튼을 클릭하면 클릭 이벤트 발생

`<button>` 요소에 클릭 이벤트가 일어나는지 감시하고 클릭 이벤트가 일어나느 순간 특정 함수를 실행시켜야 함

이때 `<button>` 태그 내의 onclick 속성을 이용해 처리 가능

- 검색 버튼을 클릭하면 검색 기능이 실행되어 화면에 검색 결과를 출력
- 저장 버튼을 클릭하면 사용자가 입력한 데이터를 서버로 보내고 DB에 저장
- 메뉴 버튼을 클릭하면 해당 메뉴로 이동 등

### change 이벤트 (onChange)
- 값이 변경되었을 때 발생하는 이벤트
- 대표적으로 `<select>`, `<input type="checkbox">`,`<input type="radio>`에서 발생

### key 이벤트(onKeydown, onkeyup, onkeypress)
key 이벤트는 사용자가 입력창에서(`<input>`태그에서) 키보드 입력시 발생.
사용자가 키를 입력하면 keydown - > keypress -> keyup의 순서로 구성

input type="text"에 keydown / keypress / keyup 이벤트를 모두 받을 수 있게 설정하고 순서 검증

현재 상황에서 chrome 자체에서 strictmode로 실행중이기에 2번씩 찍혀서 콘솔창에서 명확하게 안 보일수 있지만 입력 시점에서 onkeydown이 일어나고 키를 때면 onkeyup이 발생